# Talk Manuscript "My Ruby Is a Paintbrush, my Ruby Is a Synth"
## Explainer

This manuscript only contains parts of the talk, namely the loose bits that could have otherwise turned into long ramblings without direction.

# Why

Before we jump into the fun part containing lots of running code and finding bugs live on stage I wanted to quickly talk about my motivations behind both the talk and my general tendency to create these things. Let's start with the latter one - For a long time, until I landed my first programming gig in 1999, I was a hobby programmer. I didn't study computer science, but instead I have been tinkering with computers since my early teens, which means mid to late eighties. And even though I owned two of the most successful gaming computers, a Commodore C64 and later an AMIGA 500, I probably spent more time programming on these machines than gaming. By the time I started working for a small agency as a web developer to make some money during the last years of my studies, I had programmed in at least 8 programming languages: BASIC, 6510 Assembler, Logo, Pascal, C, 68k Assembler, E and Perl. Of course I didn't really build meaningful things with them. My most notable software projects are two weird script utilities (the AMIGA had an awesome shell scripting language (and Arexx of course)) and a tiny collaboration on a software synthesizer for the AMIGA, WaveBeast. Everything else is lost, gone forever in the digital mist of time. But that doesn't matter because what ever I was working on during those years made me the software developer I am today. I started to work in this industry in my first full time job in 2002 with at least a decade of experience in programming everything from Microcontrollers and ancient CPUs to database backed web applications.

And so I still do a lot of these little projects, most of them doomed from the start, at least if you use conventional metrics of success, but they continue to make me a better developer because they allow me to experiment in ways my work projects usually don't. Because I allow myself to write shitty code. Often, as you will see, code I write in these projects is not only shitty, it's also the barest minimum that could possibly work. I am not a big fan of abstracting upfront anyway, but in these projects you will rarely find any abstracting going on at all, simply because I know it won't be worth it. Most of my examples are between 50 and 100 lines of code. In one file. In a normal work setting, all of this won't fly, but it is a reminder, that writing good software is mostly not about the actual code. It's about the code's clarity of intent, it's maintainability and most importantly, about communication. If all of that can be dismissed, you're left with the fun, easy part which is, you know, writing code.

It's also worth to note that even within a project, code that I write is often one-off, throwaway code. A quick script to automate something or to algorithmically generate something that would take ages to do manually. Quickly written and after the needed data is generated, the code is left to rot.

And about this talk: Well, I think we all need a break sometimes. We spend so much time obsessing about the quality of our code, refactoring it to conform to all SOLID principles, keeping it up to date, maintaining it, growing it carefully, torn between the needs of users, stakeholders, colleagues, vendors and what not, and this can actually be pretty overwhelming sometimes, especially when working in a field as fast moving as web development. Working on small, fun, artsy, nonsensical and outright hilarious projects from time to time where you can ditch all of the constraints of your day job can refuel your fire that you probably felt when you first made a computer do what you wanted it to do. That was awesome, right?

Now, at this point, I have to clarify something. I am a well earning freelancer who was always able to carve out enough time for these kind of projects, and I am fully aware of how much of a privilege that is. So, if you're not able to do that, I totally understand. In this case, the only chance I see is finding a job where you have the freedom to do these things on the side. The famous "20% for fun projects" is not a pipe dream. And if you are a boss who decides these things: Think about the positive motivation your developers could get out of that time. Also: Don't impose any rules on this "extra time". Don't assume that something of value needs to come out of these projects. If one of your developers thinks they need to read a book instead of hacking on a game, then that's what they think is their time best spent. Trust your employees, they know. Or at least, they will find out.
